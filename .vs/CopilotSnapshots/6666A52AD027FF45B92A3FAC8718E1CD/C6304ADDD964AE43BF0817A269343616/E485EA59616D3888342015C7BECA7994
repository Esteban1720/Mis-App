// lib/services/settings_service.dart
// SettingsService — detecta resoluciones del sistema (16:9 / 4:3), aplica window settings robustamente,
// y persiste la configuración en disco (escritura atómica).

import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:window_manager/window_manager.dart';
import 'package:screen_retriever/screen_retriever.dart' as sr;

class SettingsService {
  SettingsService._internal();
  static final SettingsService instance = SettingsService._internal();

  // Audio
  final ValueNotifier<double> masterVolume = ValueNotifier<double>(1.0);
  final ValueNotifier<double> musicVolume = ValueNotifier<double>(0.2);
  final ValueNotifier<double> sfxVolume = ValueNotifier<double>(1.0);
  final ValueNotifier<bool> bgMusicEnabled = ValueNotifier<bool>(true);

  // Window
  final ValueNotifier<bool> isFullscreen = ValueNotifier<bool>(false);
  final ValueNotifier<Size> windowSize =
      ValueNotifier<Size>(const Size(1280, 800));

  // Controls
  final ValueNotifier<double> controllerSensitivity =
      ValueNotifier<double>(0.5);
  final ValueNotifier<bool> invertYAxis = ValueNotifier<bool>(false);

  // Persistencia
  static const _fileName = 'playstations_settings.json';

  // Cached list of detected resolutions (llenada por detectAvailableResolutions)
  List<Size> _availableResolutions = [];

  // Tolerancias (ajustables)
  static const double _aspectTolerance =
      0.04; // tolerancia para relación 16:9 / 4:3
  static const double _pixelEps =
      1.0; // tolerancia en pixeles para comparar sizes

  Future<File> _localFile() async {
    final dir = await getApplicationDocumentsDirectory();
    return File('${dir.path}/$_fileName');
  }

  Future<void> _atomicWrite(File file, String contents) async {
    final tmp = File('${file.path}.tmp');
    try {
      await tmp.writeAsString(contents);
      if (await file.exists()) {
        await file.delete();
      }
      await tmp.rename(file.path);
    } catch (e) {
      try {
        if (await tmp.exists()) await tmp.delete();
      } catch (_) {}
      rethrow;
    }
  }

  /// Carga settings desde disco. No lanza (captura errores y los loguea).
  Future<void> load() async {
    try {
      final file = await _localFile();
      if (!await file.exists()) return;
      final str = await file.readAsString();
      if (str.isEmpty) return;
      final Map<String, dynamic> json = jsonDecode(str);

      masterVolume.value =
          (json['masterVolume'] as num?)?.toDouble() ?? masterVolume.value;
      musicVolume.value =
          (json['musicVolume'] as num?)?.toDouble() ?? musicVolume.value;
      sfxVolume.value =
          (json['sfxVolume'] as num?)?.toDouble() ?? sfxVolume.value;
      bgMusicEnabled.value =
          json['bgMusicEnabled'] as bool? ?? bgMusicEnabled.value;

      isFullscreen.value = json['isFullscreen'] as bool? ?? isFullscreen.value;
      final w = (json['windowWidth'] as num?)?.toDouble();
      final h = (json['windowHeight'] as num?)?.toDouble();
      if (w != null && h != null) windowSize.value = Size(w, h);

      controllerSensitivity.value =
          (json['controllerSensitivity'] as num?)?.toDouble() ??
              controllerSensitivity.value;
      invertYAxis.value = json['invertYAxis'] as bool? ?? invertYAxis.value;
    } catch (e) {
      debugPrint('SettingsService.load() error: $e');
    }
  }

  /// Persiste settings en disco (atómico).
  Future<void> save() async {
    try {
      final file = await _localFile();
      final data = {
        'masterVolume': masterVolume.value,
        'musicVolume': musicVolume.value,
        'sfxVolume': sfxVolume.value,
        'bgMusicEnabled': bgMusicEnabled.value,
        'isFullscreen': isFullscreen.value,
        'windowWidth': windowSize.value.width,
        'windowHeight': windowSize.value.height,
        'controllerSensitivity': controllerSensitivity.value,
        'invertYAxis': invertYAxis.value,
      };
      final json = jsonEncode(data);
      await _atomicWrite(file, json);
    } catch (e) {
      debugPrint('SettingsService.save() error: $e');
    }
  }

  // ----------------- Resoluciones detectadas -----------------

  /// Detecta resoluciones aplicables para el monitor primario.
  /// - Intenta usar `screen_retriever` para obtener la pantalla primaria.
  /// - Combina la resolución nativa con fracciones útiles (1.0, 0.75, 0.5) y una lista de resoluciones comunes.
  /// - Filtra por relación de aspecto 16:9 o 4:3 (con tolerancia) y descarta resoluciones mayores que el display.
  /// Devuelve la lista ordenada por área ascendente y la cachea en `_availableResolutions`.
  Future<List<Size>> detectAvailableResolutions(
      {bool filterAspect = true}) async {
    try {
      // Resoluciones "comunes" ampliadas
      final common = <Size>[
        const Size(800, 600), // 4:3
        const Size(1024, 768), // 4:3
        const Size(1152, 864),
        const Size(1280, 720), // 16:9
        const Size(1280, 800),
        const Size(1366, 768),
        const Size(1440, 900),
        const Size(1536, 864),
        const Size(1600, 900), // 16:9
        const Size(1680, 1050),
        const Size(1920, 1080), // 16:9
        const Size(1920, 1200),
        const Size(2560, 1440), // 16:9
        const Size(2560, 1600),
        const Size(3440, 1440),
        const Size(3840, 2160), // 16:9
      ];

      // Obtener display primario con screen_retriever
      try {
        final primary = await sr.screenRetriever.getPrimaryDisplay();
        final displaySize = primary.size;
        final logicalW = displaySize.width.roundToDouble();
        final logicalH = displaySize.height.roundToDouble();

        final Set<Size> candidates = {};

        // Añadir nativo y fracciones
        final fractions = [1.0, 0.75, 0.5];
        for (final f in fractions) {
          final w = (logicalW * f).roundToDouble();
          final h = (logicalH * f).roundToDouble();
          if (w >= 640 && h >= 480) candidates.add(Size(w, h));
        }
        candidates.add(Size(logicalW, logicalH));

        // Añadir comunes que no excedan la pantalla
        for (final c in common) {
          if (c.width <= logicalW + _pixelEps &&
              c.height <= logicalH + _pixelEps) {
            candidates
                .add(Size(c.width.roundToDouble(), c.height.roundToDouble()));
          }
        }

        // Filtrar por aspecto (si se pidió)
        final list = candidates.toList();
        final filtered =
            filterAspect ? list.where(_isAspectMatch).toList() : list;

        if (filtered.isEmpty) {
          // fallback: usar algunos comunes limitados por la pantalla
          _availableResolutions = [
            Size(min(1280, logicalW), min(720, logicalH)),
            Size(min(1024, logicalW), min(768, logicalH)),
            Size(min(logicalW, logicalW), min(logicalH, logicalH)),
          ].where((s) => s.width >= 640 && s.height >= 480).toList();
        } else {
          filtered.sort(
              (a, b) => (a.width * a.height).compareTo(b.width * b.height));
          _availableResolutions = filtered;
        }
        return _availableResolutions;
      } catch (e) {
        debugPrint('screen_retriever failed: $e — usando fallback logic.');
        // caemos al fallback que usa WidgetsBinding.window
      }

      // -------- Fallback si screen_retriever no está disponible / falló --------
      final win = WidgetsBinding.instance.window;
      final physical = win.physicalSize;
      final dpr = win.devicePixelRatio;
      double logicalW = 1280;
      double logicalH = 800;
      if (!physical.isEmpty && dpr > 0) {
        logicalW = (physical.width / dpr).roundToDouble();
        logicalH = (physical.height / dpr).roundToDouble();
      }

      final Set<Size> candidates = {};
      final fractions = [1.0, 0.75, 0.5];
      for (final f in fractions) {
        final w = (logicalW * f).roundToDouble();
        final h = (logicalH * f).roundToDouble();
        if (w >= 640 && h >= 480) candidates.add(Size(w, h));
      }
      candidates.add(Size(logicalW, logicalH));
      for (final c in common) {
        if (c.width <= logicalW + _pixelEps &&
            c.height <= logicalH + _pixelEps) {
          candidates
              .add(Size(c.width.roundToDouble(), c.height.roundToDouble()));
        }
      }

      final list = candidates.toList();
      final filtered =
          filterAspect ? list.where(_isAspectMatch).toList() : list;
      if (filtered.isEmpty) {
        _availableResolutions = list
          ..sort((a, b) => (a.width * a.height).compareTo(b.width * b.height));
      } else {
        filtered
            .sort((a, b) => (a.width * a.height).compareTo(b.width * b.height));
        _availableResolutions = filtered;
      }
      return _availableResolutions;
    } catch (e) {
      debugPrint('detectAvailableResolutions unexpected error: $e');
      // último fallback fijo
      _availableResolutions = [
        const Size(800, 600),
        const Size(1024, 768),
        const Size(1280, 720),
        const Size(1366, 768),
        const Size(1920, 1080),
      ];
      return _availableResolutions;
    }
  }

  /// Devuelve la lista ya detectada (si existe) o la detecta ahora.
  Future<List<Size>> getAvailableResolutions(
      {bool forceRefresh = false}) async {
    if (_availableResolutions.isEmpty || forceRefresh) {
      return await detectAvailableResolutions();
    }
    return _availableResolutions;
  }

  /// Comprueba si una resolución tiene relación de aspecto 16:9 o 4:3 dentro de tolerancia.
  bool _isAspectMatch(Size s) {
    final ratio = s.width / s.height;
    final r16_9 = 16.0 / 9.0;
    final r4_3 = 4.0 / 3.0;
    return (ratio - r16_9).abs() <= _aspectTolerance ||
        (ratio - r4_3).abs() <= _aspectTolerance;
  }

  /// Mapea una resolución objetivo a la resolución más cercana disponible (por área).
  /// Si no hay disponibles, devuelve la misma target.
  Size mapToClosestAvailable(Size target) {
    if (_availableResolutions.isEmpty) return target;
    var best = _availableResolutions.first;
    var bestDiff =
        (best.width * best.height - target.width * target.height).abs();
    for (final c in _availableResolutions) {
      final diff = (c.width * c.height - target.width * target.height).abs();
      if (diff < bestDiff) {
        best = c;
        bestDiff = diff;
      }
    }
    return best;
  }

  /// Busca índice aproximado de `size` en la lista detectada; -1 si no existe.
  int indexOfAvailable(Size size) {
    for (int i = 0; i < _availableResolutions.length; i++) {
      final r = _availableResolutions[i];
      if ((r.width - size.width).abs() <= _pixelEps &&
          (r.height - size.height).abs() <= _pixelEps) return i;
    }
    return -1;
  }

  // ----------------- Aplicar settings de ventana (robusto) -----------------

  /// Aplica settings de ventana de forma robusta.
  /// - Si `fullscreen==true` y `size` se pasa, cambia a windowed temporalmente para setSize y vuelve a fullscreen.
  /// - Si `fullscreen==false`, sale de fullscreen antes de setSize.
  /// - Actualiza `isFullscreen` y `windowSize` y (opcionalmente) persiste.
  Future<void> applyWindowSettings(
      {bool? fullscreen, Size? size, bool persist = false}) async {
    try {
      // si no hay lista de resoluciones detectadas, intenta detectarlas
      if (_availableResolutions.isEmpty) {
        await detectAvailableResolutions();
      }

      // si se indicó `size` y hay una lista detectada: mapearlo a la versión disponible más cercana
      Size? effectiveSize = size;
      if (size != null && _availableResolutions.isNotEmpty) {
        final idx = indexOfAvailable(size);
        if (idx >= 0) {
          effectiveSize = _availableResolutions[idx];
        } else {
          effectiveSize = mapToClosestAvailable(size);
        }
      }

      // Caso: queremos aplicar BOTH fullscreen=true y tamaño específico.
      if (fullscreen == true && effectiveSize != null) {
        // Forzar temporalmente windowed para cambiar tamaño y luego fullscreen.
        await windowManager.setFullScreen(false);
        await Future.delayed(const Duration(milliseconds: 80));
        try {
          await windowManager.setSize(effectiveSize);
          windowSize.value = effectiveSize;
        } catch (e) {
          debugPrint('windowManager.setSize error (tmp windowed): $e');
        }
        await windowManager.setFullScreen(true);
        isFullscreen.value = true;
        if (persist) await save();
        return;
      }

      // Solo fullscreen true
      if (fullscreen != null && fullscreen) {
        await windowManager.setFullScreen(true);
        isFullscreen.value = true;
        if (persist) await save();
        return;
      }

      // Solo fullscreen false
      if (fullscreen != null && !fullscreen) {
        await windowManager.setFullScreen(false);
        isFullscreen.value = false;
        await Future.delayed(const Duration(milliseconds: 80));
      }

      // Si solo cambiamos tamaño (y no forzamos fullscreen true)
      if (effectiveSize != null) {
        try {
          await windowManager.setSize(effectiveSize);
          windowSize.value = effectiveSize;
        } catch (e) {
          debugPrint('windowManager.setSize error: $e');
        }
      }

      if (persist) await save();
    } catch (e) {
      debugPrint('SettingsService.applyWindowSettings error: $e');
    }
  }

  /// Reset a valores por defecto y guarda (persistente).
  Future<void> resetToDefaults() async {
    masterVolume.value = 1.0;
    musicVolume.value = 0.2;
    sfxVolume.value = 1.0;
    bgMusicEnabled.value = true;
    isFullscreen.value = false;
    windowSize.value = const Size(1280, 800);
    controllerSensitivity.value = 0.5;
    invertYAxis.value = false;
    await save();
  }
}
