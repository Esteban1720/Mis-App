// File: lib/screens/emulator_screen.dart
import 'dart:io';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:window_manager/window_manager.dart';
import 'package:file_picker/file_picker.dart';
import '../models.dart';
import '../services/emulator_manager.dart';
import '../services/emulator_helper.dart';
import '../services/input_service.dart';
import '../ui/ps5_theme.dart';
import '../services/settings_service.dart';
import '../services/audio_service.dart';
import 'settings_panel.dart';
import '../widgets/gamepad_listener.dart';
import 'emulator_input_binder.dart';
import '../widgets/onscreen_keyboard.dart';
import '../widgets/emulator_dialogs.dart';
import '../widgets/emulator_game_grid.dart';
import '../services/emulator_runner.dart';

typedef VoidCb = void Function();

class EmulatorScreen extends StatefulWidget {
  final EmulatorData emulator;
  final Future<void> Function()? onChanged;

  const EmulatorScreen({
    super.key,
    required this.emulator,
    this.onChanged,
  });

  @override
  State<EmulatorScreen> createState() => _EmulatorScreenState();
}

class _EmulatorScreenState extends State<EmulatorScreen> {
  final EmulatorManager _manager = EmulatorManager();
  final FocusNode _focusNode = FocusNode();
  final SettingsService _settings = SettingsService.instance;

  int _selectedIndex = 0;
  bool _scanning = false;
  static const int _columns = 4;

  bool _wasFullScreenBeforeLaunch = false;

  // Removed manual prev callbacks in favor of EmulatorInputBinder
  late EmulatorInputBinder _inputBinder;
  final EmulatorRunner _runner = EmulatorRunner();

  // --------------------------
// Menú de acciones por juego (navegable por gamepad)
// --------------------------
  Future<void> _openGameActions(GameData game) async {
    await showGameActionsDialog(
      context: context,
      game: game,
      manager: _manager,
      onLaunch: (g) async => await _launchGame(g),
      onRename: (g) async => await _renameGame(g),
      onChangeIcon: (g) async => await _changeIcon(g),
      onDelete: (g) async => await _deleteGame(g),
      onChanged: widget.onChanged,
    );
    _focusNode.unfocus();
    _requestFocus();
  }

  // Settings listener: para sincronizar volúmenes con AudioService
  late VoidCallback _settingsListener;

  // flag para indicar panel de settings abierto (evita suspend/resume automáticos)
  bool _settingsPanelOpen = false;

  // AppBar focus tracking: -1 = none, 0..5 action index
  int _focusedAppBar =
      -1; // 0: refresh, 1: folder, 2: settings, 3: save, 4: open emulator, 5: add pc game
  static const int _appBarActionsCount = 6;

  // Modo acciones (navegación dentro de la tarjeta seleccionada)
  int _focusedActionIndex = -1; // -1 = no en modo acciones

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) _focusNode.requestFocus();
    });

    // Initialize input binder with same logic as previous _bindInputCallbacks
    _inputBinder = EmulatorInputBinder(
      input: InputService.instance,
      onLeft: () {
        // si está enfocado el appbar, moverse entre acciones
        if (_focusedAppBar != -1) {
          _playNav();
          _focusedAppBar = (_focusedAppBar - 1) < 0
              ? (_appBarActionsCount - 1)
              : (_focusedAppBar - 1);
          setState(() {});
          return;
        }
        // si estamos en modo acciones, navegar entre botones
        if (_focusedActionIndex != -1) {
          _playNav();
          final cnt = _actionsCountForSelected();
          if (cnt > 0) {
            _focusedActionIndex = (_focusedActionIndex - 1 + cnt) % cnt;
            setState(() {});
          }
          return;
        }
        _playNav();
        _moveLeft();
      },
      onRight: () {
        if (_focusedAppBar != -1) {
          _playNav();
          _focusedAppBar = (_focusedAppBar + 1) % _appBarActionsCount;
          setState(() {});
          return;
        }
        if (_focusedActionIndex != -1) {
          _playNav();
          final cnt = _actionsCountForSelected();
          if (cnt > 0) {
            _focusedActionIndex = (_focusedActionIndex + 1) % cnt;
            setState(() {});
          }
          return;
        }
        _playNav();
        _moveRight();
      },
      onUp: () {
        // si ya en appbar, no hacer nada
        if (_focusedAppBar != -1) return;
        // si estamos en modo acciones, ignorar up para no cambiar filas
        if (_focusedActionIndex != -1) {
          // opcional: podrías salir del modo acciones con up si prefieres
          _playNav();
          return;
        }
        // si estamos en la primera fila, mover foco al appbar
        if (_isInTopRow()) {
          _playNav();
          _focusedAppBar = 0;
          setState(() {});
          return;
        }
        _playNav();
        _moveUp();
      },
      onDown: () {
        // si estamos en appbar, bajar al primer elemento (columna correspondiente)
        if (_focusedAppBar != -1) {
          _playNav();
          // map appbar position to approximate grid column
          final targetCol = _focusedAppBar.clamp(0, _columns - 1);
          final newIndex = targetCol < widget.emulator.games.length
              ? targetCol
              : (widget.emulator.games.isNotEmpty ? 0 : -1);
          if (newIndex >= 0) {
            _selectedIndex = newIndex;
          }
          _focusedAppBar = -1;
          setState(() {});
          _requestFocus();
          return;
        }

        // Si estamos en modo acciones, evitar que bajar cambie fila
        if (_focusedActionIndex != -1) {
          _playNav();
          return;
        }

        _playNav();
        _moveDown();
      },
      onActivate: () {
        // si appbar enfocado, activar acción correspondiente
        if (_focusedAppBar != -1) {
          _playAction();
          _activateAppBarAction(_focusedAppBar);
          return;
        }
        // si estamos en modo acciones, ejecutar la acción focalizada
        if (_focusedActionIndex != -1) {
          _playAction();
          _activateFocusedAction();
          return;
        }
        _playAction();
        _onActivate();
      },
      onBack: () async {
        // si appbar enfocado, lo cerramos (volver al grid)
        if (_focusedAppBar != -1) {
          _playAction();
          _focusedAppBar = -1;
          setState(() {});
          _requestFocus();
          return;
        }
        // si estamos en modo acciones, salir sin ejecutar
        if (_focusedActionIndex != -1) {
          _playAction();
          setState(() => _focusedActionIndex = -1);
          _requestFocus();
          return;
        }
        _playAction();
        await _handleBack();
      },
      onToggleFullscreen: () => _toggleFullScreen(),
      onSelect: () {
        _playAction();
        _openSettingsPanel();
      },
      onShare: () {
        _playAction();
        _openSettingsPanel();
      },
      onSettings: () {
        // si estamos en appbar, ignorar
        if (_focusedAppBar != -1) return;
        // si no hay juegos, nada que hacer
        if (widget.emulator.games.isEmpty) return;

        if (_focusedActionIndex == -1) {
          _playAction();
          _focusedActionIndex = 0;
          setState(() {});
        } else {
          _playAction();
          setState(() => _focusedActionIndex = -1);
          _requestFocus();
        }
      },
    );

    // Bindear callbacks para mando + reproducir sonidos
    _inputBinder.bind();

    // Sincronizar volúmenes (AudioService ya inicializado en main)
    AudioService.instance.applyVolumesFromSettings();
    _settingsListener = () {
      AudioService.instance.applyVolumesFromSettings();
    };
    _settings.masterVolume.addListener(_settingsListener);
    _settings.sfxVolume.addListener(_settingsListener);
    _settings.musicVolume.addListener(_settingsListener);
  }

  @override
  void dispose() {
    final input = InputService.instance;
    // Restaurar callbacks previos via binder
    try {
      _inputBinder.unbindAndRestore();
    } catch (_) {}

    _focusNode.dispose();

    // Remover listeners de settings
    _settings.masterVolume.removeListener(_settingsListener);
    _settings.sfxVolume.removeListener(_settingsListener);
    _settings.musicVolume.removeListener(_settingsListener);

    super.dispose();
  }

  // --------------------
  // Audio helpers (delegan en AudioService)
  // --------------------
  void _playNav() => AudioService.instance.playNav();
  void _playAction() => AudioService.instance.playAction();
  void _playLaunch() => AudioService.instance.playLaunch();

  // --------------------
  // Activate appbar actions
  // --------------------
  Future<void> _activateAppBarAction(int idx) async {
    switch (idx) {
      case 0: // refresh
        _scanGames();
        break;
      case 1: // change folder
        await _changeGamesFolder();
        break;
      case 2: // settings
        await _openSettingsPanel();
        break;
      case 3: // save
        if (widget.onChanged != null) await widget.onChanged!();
        ScaffoldMessenger.of(context)
            .showSnackBar(const SnackBar(content: Text('Guardado')));
        break;
      case 4: // open emulator exe
        await _openEmulatorExe();
        break;
      case 5: // add PC game (.exe)
        await _addPcGame();
        break;
    }
  }

  bool _isInTopRow() {
    // consider top row when selected index is within first row or when no selection
    if (widget.emulator.games.isEmpty) return true;
    if (_selectedIndex < 0) return true;
    return _selectedIndex < _columns;
  }

  int _actionsCountForSelected() {
    if (widget.emulator.games.isEmpty || _selectedIndex < 0) return 0;
    // actualmente tienes 3 botones (renombrar, cambiar icono, eliminar)
    int c = 0;
    if (true) c++; // renombrar
    if (true) c++; // cambiar ícono
    if (true) c++; // eliminar
    return c;
  }

  Future<void> _activateFocusedAction() async {
    if (_selectedIndex < 0 || _selectedIndex >= widget.emulator.games.length)
      return;
    final game = widget.emulator.games[_selectedIndex];
    final idx = _focusedActionIndex;
    // salir del modo acciones para que el UI no quede bloqueado
    setState(() => _focusedActionIndex = -1);

    try {
      switch (idx) {
        case 0: // Renombrar: usar teclado en pantalla para gamepad
          final typed = await _showOnScreenKeyboard(initial: game.displayName);
          if (typed != null && typed.isNotEmpty) {
            final oldPath = game.path;
            setState(() => game.displayName = typed);
            try {
              await _manager.renameGamePersistent(oldPath, typed);
            } catch (e) {
              debugPrint(
                  'rename persistent error after on-screen keyboard: $e');
            }
            if (widget.onChanged != null) await widget.onChanged!();
            ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Nombre actualizado')));
          }
          break;
        case 1: // Cambiar ícono
          await _changeIcon(game);
          break;
        case 2: // Eliminar
          await _deleteGame(game);
          break;
        default:
          break;
      }
    } catch (e, st) {
      debugPrint('_activateFocusedAction error: $e\n$st');
    } finally {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) _focusNode.requestFocus();
      });
    }
  }

  // --------------------
  // Navigation helpers
  // --------------------
  void _moveLeft() {
    final games = widget.emulator.games;
    if (games.isEmpty) return;
    setState(() {
      if (_selectedIndex <= 0) {
        _selectedIndex = games.length - 1;
      } else {
        _selectedIndex--;
      }
    });
    _requestFocus();
  }

  void _moveRight() {
    final games = widget.emulator.games;
    if (games.isEmpty) return;
    setState(() {
      _selectedIndex = (_selectedIndex + 1) % games.length;
    });
    _requestFocus();
  }

  void _moveUp() {
    final games = widget.emulator.games;
    if (games.isEmpty) return;
    final posInCol = _selectedIndex % _columns;
    final rows = (games.length / _columns).ceil();
    final currRow = (_selectedIndex / _columns).floor();
    int targetRow = currRow - 1;
    if (targetRow < 0) targetRow = rows - 1;
    int target = targetRow * _columns + posInCol;
    if (target >= games.length) target = games.length - 1;
    setState(() => _selectedIndex = target);
    _requestFocus();
  }

  void _moveDown() {
    final games = widget.emulator.games;
    if (games.isEmpty) return;
    final posInCol = _selectedIndex % _columns;
    final rows = (games.length / _columns).ceil();
    final currRow = (_selectedIndex / _columns).floor();
    int targetRow = currRow + 1;
    if (targetRow >= rows) targetRow = 0;
    int target = targetRow * _columns + posInCol;
    if (target >= games.length) target = games.length - 1;
    setState(() => _selectedIndex = target);
    _requestFocus();
  }

  void _onActivate() {
    final games = widget.emulator.games;
    if (games.isEmpty) {
      _scanGames();
      return;
    }
    if (_selectedIndex < 0 || _selectedIndex >= games.length) return;
    _launchGame(games[_selectedIndex]);
  }

  Future<void> _toggleFullScreen() async {
    try {
      await InputService.instance.toggleFullscreen();
    } catch (e) {
      debugPrint('toggle fullscreen error: $e');
    }
  }

  void _requestFocus() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) _focusNode.requestFocus();
    });
  }

  Future<void> _handleBack() async {
    if (widget.onChanged != null) {
      try {
        await widget.onChanged!();
      } catch (e) {
        debugPrint('onChanged callback error: $e');
      }
    }
    if (mounted) Navigator.pop(context);
  }

  // --------------------
  // Scan / Launch / Open EXE / Change folder
  // --------------------
  Future<void> _scanGames() async {
    // Si esta tarjeta es manual (PC), no hacer escaneo automático.
    if (widget.emulator.manualAddsOnly) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
          content: Text(
              'Esta tarjeta no realiza escaneos. Usa "Agregar juego" para añadir .exe manualmente.')));
      return;
    }

    setState(() => _scanning = true);
    try {
      await _manager.scanGamesForEmulator(widget.emulator);
      if (widget.onChanged != null) await widget.onChanged!();
      setState(() {
        if (widget.emulator.games.isEmpty) {
          _selectedIndex = 0;
        } else if (_selectedIndex >= widget.emulator.games.length) {
          _selectedIndex = widget.emulator.games.length - 1;
        }
      });
      _playAction();
      ScaffoldMessenger.of(context)
          .showSnackBar(const SnackBar(content: Text('Escaneo completado')));
    } catch (e) {
      debugPrint('scan error: $e');
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text('Error al escanear: $e')));
    } finally {
      setState(() => _scanning = false);
    }
  }

  // Nuevo helper: unifica el comportamiento repetido de iniciar un proceso y la limpieza cuando sale.
  Future<void> _startProcessAndHandle(
    String exe,
    List<String> args,
    String wd, {
    required String startingSnack,
    required bool playLaunchSound,
    String? stdoutTag,
  }) async {
    try {
      await _runner.startProcessAndHandle(
        exe: exe,
        args: args,
        wd: wd,
        startingSnack: startingSnack,
        playLaunchSound: playLaunchSound,
        onStdout: (d) => debugPrint('${stdoutTag ?? exe} STDOUT: $d'),
        onStderr: (d) => debugPrint('${stdoutTag ?? exe} STDERR: $d'),
        onCleanup: () async {
          await _runner.handleProcessExitCleanup();
        },
        onRestoreInput: () async {
          if (!_settingsPanelOpen) {
            try {
              _inputBinder.bind();
              await InputService.instance.resume();
              debugPrint(
                  'EmulatorScreen: input resumed and callbacks re-bound');
            } catch (e) {
              debugPrint('InputService.resume() error: $e');
            }
          }
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) _focusNode.requestFocus();
          });
        },
      );
      if (playLaunchSound) _playLaunch();
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text(startingSnack)));
        } catch (_) {}
      }
    } catch (e) {
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(const SnackBar(content: Text('Archivo no encontrado.')));
        } catch (_) {}
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final games = widget.emulator.games;
    final bg = EmulatorHelper.getEmulatorBackground(widget.emulator.name);
    return WillPopScope(
      onWillPop: () async {
        await _handleBack();
        return false;
      },
      child: Scaffold(
        appBar: AppBar(
          title: Text(widget.emulator.name.toUpperCase()),
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () {
              _playAction();
              _handleBack();
            },
          ),
          actions: [
            // Each action is wrapped so we can show focused state when controller
            _buildAppBarAction(
              icon: Icons.refresh,
              tooltip: 'Escanear juegos',
              index: 0,
              onPressed: () {
                if (_scanning) return;
                _playAction();
                _scanGames();
              },
            ),
            _buildAppBarAction(
              icon: Icons.folder_open,
              tooltip: 'Cambiar carpeta de juegos',
              index: 1,
              onPressed: () {
                _playAction();
                _changeGamesFolder();
              },
            ),
            _buildAppBarAction(
              icon: Icons.settings,
              tooltip: 'Abrir panel de ajustes',
              index: 2,
              onPressed: () {
                _playAction();
                _openSettingsPanel();
              },
            ),
            _buildAppBarAction(
              icon: Icons.save,
              tooltip: 'Forzar guardar',
              index: 3,
              onPressed: () async {
                _playAction();
                if (widget.onChanged != null) await widget.onChanged!();
                ScaffoldMessenger.of(context)
                    .showSnackBar(const SnackBar(content: Text('Guardado')));
              },
            ),
            // Nuevo: boton para abrir el ejecutable del emulador
            _buildAppBarAction(
              icon: Icons.play_arrow,
              tooltip: 'Abrir emulador',
              index: 4,
              onPressed: () async {
                _playAction();
                await _openEmulatorExe();
              },
            ),

            // Nuevo (solo visible en tarjetas manualAddsOnly / PC): Agregar .exe
            if (widget.emulator.manualAddsOnly)
              _buildAppBarAction(
                icon: Icons.add_box,
                tooltip: 'Agregar juego (.exe)',
                index: 5,
                onPressed: () async {
                  _playAction();
                  await _addPcGame();
                },
              ),
          ],
        ),
        body: RawKeyboardListener(
          focusNode: _focusNode,
          onKey: _onRawKey,
          child: Container(
            decoration: BoxDecoration(
              image: DecorationImage(
                image: AssetImage(bg),
                fit: BoxFit.cover,
              ),
            ),
            child: Column(
              children: [
                if (widget.emulator.gamesPath != null)
                  Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text('Carpeta: ${widget.emulator.gamesPath}',
                        style: const TextStyle(fontSize: 12)),
                  ),
                Expanded(
                  child: games.isEmpty
                      ? const Center(
                          child: Text('No se encontraron juegos',
                              style: TextStyle(color: Colors.white)))
                      : EmulatorGameGrid(
                          games: games,
                          columns: _columns,
                          selectedIndex: _selectedIndex,
                          focusedAppBar: _focusedAppBar,
                          focusedActionIndex: _focusedActionIndex,
                          emulatorName: widget.emulator.name,
                          onSelect: (i) {
                            setState(() {
                              _selectedIndex = i;
                              _focusedActionIndex = -1;
                            });
                            _playAction();
                            _launchGame(games[i]);
                          },
                          onLongPress: (i) {
                            setState(() {
                              _selectedIndex = i;
                              _focusedActionIndex = 0;
                            });
                            _playAction();
                            _openGameActions(games[i]);
                          },
                          onDelete: (i) {
                            _playAction();
                            _deleteGame(games[i]);
                          },
                          onRename: (i) {
                            _playAction();
                            _renameGame(games[i]);
                          },
                          onChangeIcon: (i) {
                            _playAction();
                            _changeIcon(games[i]);
                          },
                        ),
                ),
              ],
            },
          ),
        ),
      ),
    );
  }

  // Build helper for opening settings panel (restored)
  Future<void> _openSettingsPanel() async {
    if (!mounted) return;

    final controller = SettingsPanelController();
    final input = InputService.instance;

    final settingsListener = InputListener(
      onLeft: () => controller.onLeft?.call(),
      onRight: () => controller.onRight?.call(),
      onUp: () => controller.onUp?.call(),
      onDown: () => controller.onDown?.call(),
      onActivate: () => controller.onActivate?.call(),
      onBack: () => controller.onBack?.call(),
      onToggleFullscreen: () {},
      onSelect: () {},
      onShare: () => controller.onReset?.call(),
      onSettings: () => controller.onApply?.call(),
    );

    final removeListener = input.pushListener(settingsListener);

    // Unbind emulator input so previous handlers (e.g. Home) are restored.
    try {
      _inputBinder.unbindAndRestore();
    } catch (_) {}

    _focusNode.unfocus();

    try {
      AudioService.instance.applyVolumesFromSettings();
    } catch (_) {}

    _settingsPanelOpen = true;

    try {
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => SettingsPanel(controller: controller, asRoute: true),
          fullscreenDialog: true,
        ),
      );
    } finally {
      try {
        removeListener();
      } catch (_) {}

      _settingsPanelOpen = false;

      // Do NOT restore emulator input bindings here — when settings are opened from
      // EmulatorScreen we intentionally return to Home (popUntil first route). If we
      // rebind emulator handlers before popping, Home will receive emulator callbacks.
      // Instead, perform the navigation back to the first route and let Home restore
      // its own input handlers.
      WidgetsBinding.instance.addPostFrameCallback((_) {
        try {
          if (mounted) {
            Navigator.of(context).popUntil((route) => route.isFirst);
          }
        } catch (_) {}
      });
    }
  }

  Widget _buildAppBarAction({
    required IconData icon,
    required String tooltip,
    required int index,
    required VoidCb onPressed,
  }) {
    final focused = _focusedAppBar == index;
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 6.0),
      child: GestureDetector(
        onTap: onPressed,
        child: Container(
          decoration: focused
              ? BoxDecoration(
                  border:
                      Border.all(color: const Color(0xFF66E0FF), width: 2.0),
                  borderRadius: BorderRadius.circular(6.0),
                )
              : null,
          child: IconButton(
            icon: Icon(icon, color: focused ? Colors.white : Colors.white70),
            tooltip: tooltip,
            onPressed: onPressed,
          ),
        ),
      ),
    );
  }

  // Restore methods that other modules expect (moved earlier by refactor)

  // Show on-screen keyboard wrapper
  Future<String?> _showOnScreenKeyboard({String initial = ''}) async {
    final result = await showDialog<String?>(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => OnScreenKeyboard(
          initialValue: initial, title: 'Renombrar', maxLength: 64),
    );
    return result;
  }

  // _launchGame restored (delegates to previous in-file implementation)
  Future<void> _launchGame(GameData game) async {
    try {
      if (widget.emulator.manualAddsOnly) {
        final exePath = game.path;
        final wd = File(exePath).parent.path;
        await _startProcessAndHandle(
          exePath,
          <String>[],
          wd,
          startingSnack: 'Lanzando ${game.displayName}',
          playLaunchSound: true,
          stdoutTag: 'PC GAME',
        );
        return;
      }

      final exe = widget.emulator.exePath;
      if (!File(exe).existsSync()) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content: Text('Archivo del emulador no encontrado.')));
        return;
      }

      final argsFromHelper = EmulatorHelper.buildLaunchArgsForGame(
        emulatorName: widget.emulator.name,
        gamePath: game.path,
        fullscreen: widget.emulator.launchFullscreen,
        extraArgs: widget.emulator.launchArgs,
      );

      final lowerName = widget.emulator.name.toLowerCase();
      final args = <String>[];
      if (lowerName.contains('dolphin') ||
          exe.toLowerCase().contains('dolphin')) {
        args.addAll(['--batch']);
        if (argsFromHelper.any((a) => a == '-e' || a.startsWith('--exec'))) {
          args.addAll(argsFromHelper);
        } else {
          args.addAll(['--exec=${game.path}']);
          if (widget.emulator.launchArgs.isNotEmpty) {
            args.addAll(widget.emulator.launchArgs);
          }
        }
      } else {
        args.addAll(argsFromHelper);
      }

      final wd = widget.emulator.workingDirectory ??
          File(widget.emulator.exePath).parent.path;

      await _startProcessAndHandle(
        exe,
        args,
        wd,
        startingSnack: 'Lanzando ${game.displayName}',
        playLaunchSound: true,
        stdoutTag: 'EMU',
      );
    } catch (e, st) {
      debugPrint('Launch error: $e$st');
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text('Error al lanzar: $e')));
        } catch (_) {}
      }
    }
  }

  Future<void> _openEmulatorExe() async {
    try {
      final exe = widget.emulator.exePath;
      if (!File(exe).existsSync()) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content: Text('Archivo del emulador no encontrado.')));
        return;
      }

      final args = List<String>.from(widget.emulator.launchArgs);
      final wd = widget.emulator.workingDirectory ??
          File(widget.emulator.exePath).parent.path;

      await _startProcessAndHandle(
        exe,
        args,
        wd,
        startingSnack: 'Abriendo emulador...',
        playLaunchSound: false,
        stdoutTag: 'EMU EXE',
      );
    } catch (e, st) {
      debugPrint('_openEmulatorExe error: $e$st');
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text('Error al abrir emulador: $e')));
        } catch (_) {}
      }
    }
  }

  Future<void> _changeGamesFolder() async {
    try {
      final path = await FilePicker.platform.getDirectoryPath(
        dialogTitle:
            'Selecciona la carpeta de juegos para ${widget.emulator.name}',
      );
      if (path == null) return;

      setState(() {
        widget.emulator.gamesPath = path;
      });

      await _manager.saveEmulators([widget.emulator]);
      await _manager.scanGamesForEmulator(widget.emulator,
          baseDir: Directory(path));
      if (widget.onChanged != null) await widget.onChanged!();

      _playAction();
      ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(content: Text('Carpeta actualizada: $path')));
    } catch (e) {
      debugPrint('changeGamesFolder error: $e');
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text('Error cambiando carpeta: $e')));
        } catch (_) {}
      }
    }
  }

  Future<void> _addPcGame() async {
    try {
      if (!widget.emulator.manualAddsOnly) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content: Text(
                'La función Agregar .exe solo está disponible en tarjetas PC.')));
        return;
      }
      final result = await FilePicker.platform
          .pickFiles(type: FileType.custom, allowedExtensions: ['exe']);
      if (result == null || result.files.isEmpty) return;
      final path = result.files.single.path;
      if (path == null) return;
      final newGame =
          GameData(path: path, displayName: EmulatorHelper.cleanGameName(path));
      setState(() {
        widget.emulator.games.removeWhere((g) => g.path == newGame.path);
        widget.emulator.games.add(newGame);
        _selectedIndex = widget.emulator.games.length - 1;
      });
      await _manager.saveEmulators([widget.emulator]);
      if (widget.onChanged != null) await widget.onChanged!();
      _playAction();
      ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Juego agregado: ${newGame.displayName}')));
    } catch (e) {
      debugPrint('_addPcGame error: $e');
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text('Error agregando .exe: $e')));
        } catch (_) {}
      }
    }
  }

  Future<void> _changeIcon(GameData game) async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['png', 'jpg', 'jpeg', 'webp', 'gif', 'bmp'],
      );
      if (result == null || result.files.isEmpty) return;
      final path = result.files.single.path;
      if (path == null) return;
      setState(() => game.coverUrl = path);
      _playAction();
      if (widget.onChanged != null) {
        await widget.onChanged!();
      } else {
        await _manager.saveEmulators([widget.emulator]);
      }
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Icono/portada actualizada')));
    } catch (e) {
      debugPrint('changeIcon error: $e');
      if (mounted) {
        try {
          ScaffoldMessenger.of(context)
              .showSnackBar(SnackBar(content: Text('Error al cambiar icono: $e')));
        } catch (_) {}
      }
    }
  }

  Future<void> _deleteGame(GameData game) async {
    final confirm = await showDeleteGameDialog(context: context, game: game);
    if (confirm == true) {
      setState(() {
        widget.emulator.games.removeWhere((g) => g.path == game.path);
        if (_selectedIndex >= widget.emulator.games.length) {
          _selectedIndex = widget.emulator.games.isEmpty
              ? 0
              : widget.emulator.games.length - 1;
        }
      });
      _playAction();
      if (widget.onChanged != null) await widget.onChanged!();
    } else {
      _requestFocus();
    }
  }

  Future<void> _renameGame(GameData game) async {
    final controller = TextEditingController(text: game.displayName);
    final result = await showDialog<String?>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Renombrar juego (solo en la app)'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(labelText: 'Nuevo nombre'),
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, null),
              child: const Text('Cancelar')),
          TextButton(
              onPressed: () => Navigator.pop(context, controller.text.trim()),
              child: const Text('Guardar')),
        ],
      ),
    );
    if (result != null && result.isNotEmpty) {
      final oldPath = game.path;
      setState(() => game.displayName = result);
      await _manager.renameGamePersistent(oldPath, result);
      _playAction();
      if (widget.onChanged != null) await widget.onChanged!();
      ScaffoldMessenger.of(context)
          .showSnackBar(const SnackBar(content: Text('Nombre actualizado')));
    }
  }

  // Keyboard handling (restore)
  void _onRawKey(RawKeyEvent event) {
    if (event is! RawKeyDownEvent) return;
    final key = event.logicalKey;
    if (_focusedAppBar != -1) {
      if (key == LogicalKeyboardKey.arrowLeft) {
        _playNav();
        setState(() => _focusedAppBar = (_focusedAppBar - 1) < 0
            ? (_appBarActionsCount - 1)
            : (_focusedAppBar - 1));
        return;
      } else if (key == LogicalKeyboardKey.arrowRight) {
        _playNav();
        setState(
            () => _focusedAppBar = (_focusedAppBar + 1) % _appBarActionsCount);
        return;
      } else if (key == LogicalKeyboardKey.enter ||
          key == LogicalKeyboardKey.numpadEnter) {
        _playAction();
        _activateAppBarAction(_focusedAppBar);
        return;
      } else if (key == LogicalKeyboardKey.escape ||
          key == LogicalKeyboardKey.goBack) {
        _playAction();
        setState(() => _focusedAppBar = -1);
        _requestFocus();
        return;
      }
    }

    if (_focusedActionIndex != -1) {
      if (key == LogicalKeyboardKey.arrowLeft) {
        _playNav();
        final cnt = _actionsCountForSelected();
        _focusedActionIndex = (_focusedActionIndex - 1 + cnt) % cnt;
        setState(() {});
        return;
      } else if (key == LogicalKeyboardKey.arrowRight) {
        _playNav();
        final cnt = _actionsCountForSelected();
        _focusedActionIndex = (_focusedActionIndex + 1) % cnt;
        setState(() {});
        return;
      } else if (key == LogicalKeyboardKey.enter ||
          key == LogicalKeyboardKey.numpadEnter) {
        _playAction();
        _activateFocusedAction();
        return;
      } else if (key == LogicalKeyboardKey.escape ||
          key == LogicalKeyboardKey.goBack) {
        _playAction();
        setState(() => _focusedActionIndex = -1);
        _requestFocus();
        return;
      }
    }

    if (key == LogicalKeyboardKey.arrowDown) {
      _playNav();
      _moveDown();
    } else if (key == LogicalKeyboardKey.arrowUp) {
      _playNav();
      if (_isInTopRow()) {
        setState(() => _focusedAppBar = 0);
        return;
      }
      _moveUp();
    } else if (key == LogicalKeyboardKey.arrowLeft) {
      _playNav();
      _moveLeft();
    } else if (key == LogicalKeyboardKey.arrowRight) {
      _playNav();
      _moveRight();
    } else if (key == LogicalKeyboardKey.enter ||
        key == LogicalKeyboardKey.numpadEnter) {
      _playAction();
      _onActivate();
    } else if (key == LogicalKeyboardKey.escape ||
        key == LogicalKeyboardKey.goBack) {
      _playAction();
      _handleBack();
    } else if (key == LogicalKeyboardKey.f11) {
      _toggleFullScreen();
    }
  }
}
