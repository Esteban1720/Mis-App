// lib/services/audio_service.dart
import 'dart:async';
import 'package:audioplayers/audioplayers.dart';
import 'settings_service.dart';

/// Servicio singleton para efectos de sonido (SFX).
/// Centraliza la creación de AudioPlayers para evitar crear/destruir
/// repetidamente y reducir la probabilidad de errores de threading
/// en el plugin audioplayers.
class AudioService {
  AudioService._internal();
  static final AudioService instance = AudioService._internal();

  // AudioPlayers for SFX
  final AudioPlayer _nav = AudioPlayer();
  final AudioPlayer _action = AudioPlayer();
  final AudioPlayer _launch = AudioPlayer();

  bool _initialized = false;

  Future<void> init() async {
    if (_initialized) return;
    _initialized = true;

    try {
      await _nav.setSource(AssetSource('sounds/nav.wav'));
    } catch (_) {}
    try {
      await _action.setSource(AssetSource('sounds/action.wav'));
    } catch (_) {}
    try {
      await _launch.setSource(AssetSource('sounds/launch.wav'));
    } catch (_) {}

    try {
      // For SFX we want them to stop when done
      await _launch.setReleaseMode(ReleaseMode.stop);
      await _nav.setReleaseMode(ReleaseMode.stop);
      await _action.setReleaseMode(ReleaseMode.stop);
    } catch (_) {}

    // Aplicar volúmenes iniciales desde settings
    applyVolumesFromSettings();

    // Escuchar cambios de settings para mantener sincronía
    final s = SettingsService.instance;
    s.masterVolume.addListener(applyVolumesFromSettings);
    s.sfxVolume.addListener(applyVolumesFromSettings);
    s.musicVolume.addListener(applyVolumesFromSettings);
  }

  void applyVolumesFromSettings() {
    final s = SettingsService.instance;
    final master = s.masterVolume.value;
    final sfx = s.sfxVolume.value;

    try {
      _nav.setVolume((master * sfx).clamp(0.0, 1.0));
    } catch (_) {}
    try {
      _action.setVolume((master * sfx).clamp(0.0, 1.0));
    } catch (_) {}
    try {
      _launch.setVolume((master * sfx).clamp(0.0, 1.0));
    } catch (_) {}
  }

  // Helper: call fn immediately; avoid scheduling on post-frame to reduce latency.
  void _runImmediate(FutureOr<void> Function() fn) {
    try {
      fn();
    } catch (_) {}
  }

  void playNav() {
    _runImmediate(() async {
      try {
        await _nav.seek(Duration.zero);
        await _nav.resume();
      } catch (_) {
        try {
          await _nav.play(AssetSource('sounds/nav.wav'));
        } catch (_) {}
      }
    });
  }

  void playAction() {
    _runImmediate(() async {
      try {
        await _action.seek(Duration.zero);
        await _action.resume();
      } catch (_) {
        try {
          await _action.play(AssetSource('sounds/action.wav'));
        } catch (_) {}
      }
    });
  }

  void playLaunch() {
    _runImmediate(() async {
      try {
        await _launch.seek(Duration.zero);
        await _launch.resume();
      } catch (_) {
        try {
          await _launch.play(AssetSource('sounds/launch.wav'));
        } catch (_) {}
      }
    });
  }

  Future<void> dispose() async {
    try {
      await _nav.dispose();
    } catch (_) {}
    try {
      await _action.dispose();
    } catch (_) {}
    try {
      await _launch.dispose();
    } catch (_) {}
    _initialized = false;
  }
}
