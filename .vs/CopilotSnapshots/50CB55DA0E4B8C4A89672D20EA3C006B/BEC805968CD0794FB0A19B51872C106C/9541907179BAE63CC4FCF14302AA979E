// lib/screens/settings_panel.dart
// Settings panel — integración definitiva con SettingsService.getAvailableResolutions()
// - Usa índices en el DropdownButton para evitar problemas de igualdad entre Size instances.
// - Carga resoluciones mediante SettingsService.getAvailableResolutions() al iniciar.
// - Mapea cambios externos a la resolución disponible más cercana.
// - Mantiene toda la UX previa (foco, navegación con teclado/mando, apply/reset).

import 'dart:async';
import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'
    show rootBundle, LogicalKeyboardKey, RawKeyDownEvent, RawKeyEvent;
import 'package:file_picker/file_picker.dart';
import 'dart:io';
import '../services/settings_service.dart';
import '../widgets/gamepad_listener.dart';

class SettingsPanelController {
  void Function()? onUp;
  void Function()? onDown;
  void Function()? onLeft;
  void Function()? onRight;
  void Function()? onActivate;
  void Function()? onBack;
  void Function()? onApply;
  void Function()? onReset;
  void dispose() {}
}

class SettingsPanel extends StatefulWidget {
  final SettingsPanelController? controller;
  final bool asRoute;

  const SettingsPanel({Key? key, this.controller, this.asRoute = false})
      : super(key: key);

  @override
  State<SettingsPanel> createState() => _SettingsPanelState();
}

class _SettingsPanelState extends State<SettingsPanel> {
  final s = SettingsService.instance;

  // debounce / busy
  bool _busy = false;
  int _lastActionAt = 0;
  static const int _actionDebounceMs = 140; // más responsivo para teclado

  // resoluciones: provienen de SettingsService.getAvailableResolutions()
  List<Size> _resolutions = [];
  int _pendingWindowResolutionIndex = 0; // índice en _resolutions

  // focus map
  int _focusIndex = 0;
  int get _maxFocus => _focusKeys.length - 1;

  // pending values (solo aquí; NO tocan SettingsService hasta aplicar)
  late double _pendingMasterVolume;
  late double _pendingMusicVolume;
  late double _pendingSfxVolume;
  Size? _pendingWindowSize; // espejo del índice (se mantiene por conveniencia)
  late bool _pendingFullscreen;
  // replaced controller sensitivity with bg music selection
  late bool _pendingBgMusicEnabled;
  String? _pendingBgMusicPath;
  late bool _pendingInvertYAxis;

  static const double _step = 0.05;

  ImageProvider? _bgImage;
  bool _bgLoaded = false;

  final ScrollController _scrollController = ScrollController();
  final Map<int, GlobalKey> _focusKeys = {
    for (var i = 0; i <= 9; i++) i: GlobalKey()
  };
  final FocusNode _keyboardFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();

    // Inicializar borrador desde SettingsService (snapshot)
    _pendingMasterVolume = s.masterVolume.value;
    _pendingMusicVolume = s.musicVolume.value;
    _pendingSfxVolume = s.sfxVolume.value;
    _pendingWindowSize = s.windowSize.value;
    _pendingFullscreen = s.isFullscreen.value;
    _pendingBgMusicEnabled = s.bgMusicEnabled.value;
    _pendingBgMusicPath = s.audio.bgMusicPath.value;
    _pendingInvertYAxis = s.invertYAxis.value;

    if (widget.controller != null) {
      widget.controller!.onUp = _onUp;
      widget.controller!.onDown = _onDown;
      widget.controller!.onLeft = _onLeft;
      widget.controller!.onRight = _onRight;
      widget.controller!.onActivate = _onActivate;
      widget.controller!.onBack = _onBack;
      widget.controller!.onApply = _applyFromController;
      widget.controller!.onReset = _resetFromController;
    }

    // listeners externos
    s.windowSize.addListener(_onExternalChange);
    s.isFullscreen.addListener(_onExternalChange);
    s.masterVolume.addListener(_onExternalChange);
    s.musicVolume.addListener(_onExternalChange);
    s.sfxVolume.addListener(_onExternalChange);
    s.bgMusicEnabled.addListener(_onExternalChange);
    s.audio.bgMusicPath.addListener(_onExternalChange);
    s.invertYAxis.addListener(_onExternalChange);

    _tryLoadBg();

    // cargar resoluciones detectadas desde SettingsService
    _loadResolutions();

    // pedimos foco para capturar teclado
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) _keyboardFocusNode.requestFocus();
    });
  }

  @override
  void dispose() {
    if (widget.controller != null) {
      widget.controller!.onUp = null;
      widget.controller!.onDown = null;
      widget.controller!.onLeft = null;
      widget.controller!.onRight = null;
      widget.controller!.onActivate = null;
      widget.controller!.onBack = null;
      widget.controller!.onApply = null;
      widget.controller!.onReset = null;
    }
    s.windowSize.removeListener(_onExternalChange);
    s.isFullscreen.removeListener(_onExternalChange);
    s.masterVolume.removeListener(_onExternalChange);
    s.musicVolume.removeListener(_onExternalChange);
    s.sfxVolume.removeListener(_onExternalChange);
    s.bgMusicEnabled.removeListener(_onExternalChange);
    s.audio.bgMusicPath.removeListener(_onExternalChange);
    s.invertYAxis.removeListener(_onExternalChange);
    _scrollController.dispose();
    _keyboardFocusNode.dispose();
    super.dispose();
  }

  Future<void> _loadResolutions() async {
    try {
      // pedir lista (no forzamos refresh por defecto)
      final list = await s.getAvailableResolutions();
      if (!mounted) return;

      setState(() {
        _resolutions = list;
        // alinear _pendingWindowSize a un índice válido
        if (_resolutions.isEmpty) {
          _pendingWindowResolutionIndex = 0;
        } else if (_pendingWindowSize != null) {
          final idx = s.indexOfAvailable(_pendingWindowSize!);
          if (idx >= 0) {
            _pendingWindowResolutionIndex = idx;
            _pendingWindowSize = _resolutions[idx];
          } else {
            final closest = s.mapToClosestAvailable(
                _pendingWindowSize ?? _resolutions.first);
            _pendingWindowSize = closest;
            _pendingWindowResolutionIndex =
                _resolutions.indexOf(closest).clamp(0, _resolutions.length - 1);
          }
        } else {
          _pendingWindowResolutionIndex = 0;
          _pendingWindowSize = _resolutions[0];
        }
      });
    } catch (e) {
      debugPrint('Error loading resolutions: $e');
      // dejar la UI funcionando aunque no se puedan obtener resoluciones
      if (!mounted) return;
      setState(() {
        _resolutions = [];
        _pendingWindowResolutionIndex = 0;
      });
    }
  }

  void _onExternalChange() {
    // sincronizar borrador con settings externos y mapear resolución a opción disponible
    if (!mounted) return;
    setState(() {
      _pendingMasterVolume = s.masterVolume.value;
      _pendingMusicVolume = s.musicVolume.value;
      _pendingSfxVolume = s.sfxVolume.value;
      _pendingFullscreen = s.isFullscreen.value;
      _pendingBgMusicEnabled = s.bgMusicEnabled.value;
      _pendingBgMusicPath = s.audio.bgMusicPath.value;
      _pendingInvertYAxis = s.invertYAxis.value;

      final externalSize = s.windowSize.value;
      if (_resolutions.isNotEmpty) {
        final idx = s.indexOfAvailable(externalSize);
        if (idx >= 0) {
          _pendingWindowResolutionIndex = idx;
          _pendingWindowSize = _resolutions[idx];
        } else {
          final closest = s.mapToClosestAvailable(externalSize);
          _pendingWindowSize = closest;
          _pendingWindowResolutionIndex =
              _resolutions.indexOf(closest).clamp(0, _resolutions.length - 1);
        }
      } else {
        _pendingWindowSize = externalSize;
      }
    });
  }

  Future<void> _tryLoadBg() async {
    const exts = ['.jpg', '.jpeg', '.png', '.webp'];
    const base = 'assets/images/fondoconfig';
    for (final ext in exts) {
      final p = '$base$ext';
      try {
        await rootBundle.load(p);
        final prov = AssetImage(p);
        if (!mounted) return;
        await precacheImage(prov, context);
        if (!mounted) return;
        setState(() {
          _bgImage = prov;
          _bgLoaded = true;
        });
        return;
      } catch (_) {}
    }
    try {
      const fallback = 'assets/images/principal.jpg';
      await rootBundle.load(fallback);
      final prov = const AssetImage(fallback);
      if (!mounted) return;
      await precacheImage(prov, context);
      if (!mounted) return;
      setState(() {
        _bgImage = prov;
        _bgLoaded = true;
      });
    } catch (_) {}
  }

  // ---------------- navigation without wrap ----------------
  void _onUp() {
    if (!mounted) return;
    FocusScope.of(context).requestFocus(_keyboardFocusNode);
    setState(() {
      if (_focusIndex > 0) _focusIndex--;
    });
    _ensureFocusVisible();
  }

  void _onDown() {
    if (!mounted) return;
    FocusScope.of(context).requestFocus(_keyboardFocusNode);
    setState(() {
      if (_focusIndex < _maxFocus) _focusIndex++;
    });
    _ensureFocusVisible();
  }

  void _onLeft() {
    if (!mounted) return;
    setState(() {
      switch (_focusIndex) {
        case 0:
          _pendingMasterVolume = (_pendingMasterVolume - _step).clamp(0.0, 1.0);
          break;
        case 1:
          _pendingMusicVolume = (_pendingMusicVolume - _step).clamp(0.0, 1.0);
          break;
        case 2:
          _pendingSfxVolume = (_pendingSfxVolume - _step).clamp(0.0, 1.0);
          break;
        case 3:
          // mover índice a la resolución anterior (más pequeña)
          if (_resolutions.isNotEmpty) {
            _pendingWindowResolutionIndex =
                max(0, _pendingWindowResolutionIndex - 1);
            _pendingWindowSize = _resolutions[_pendingWindowResolutionIndex];
          }
          break;
        case 5:
          // toggle bg music off
          _pendingBgMusicEnabled = false;
          break;
      }
    });
  }

  void _onRight() {
    if (!mounted) return;
    setState(() {
      switch (_focusIndex) {
        case 0:
          _pendingMasterVolume = (_pendingMasterVolume + _step).clamp(0.0, 1.0);
          break;
        case 1:
          _pendingMusicVolume = (_pendingMusicVolume + _step).clamp(0.0, 1.0);
          break;
        case 2:
          _pendingSfxVolume = (_pendingSfxVolume + _step).clamp(0.0, 1.0);
          break;
        case 3:
          if (_resolutions.isNotEmpty) {
            _pendingWindowResolutionIndex =
                min(_resolutions.length - 1, _pendingWindowResolutionIndex + 1);
            _pendingWindowSize = _resolutions[_pendingWindowResolutionIndex];
          }
          break;
        case 5:
          // toggle bg music on
          _pendingBgMusicEnabled = true;
          break;
      }
    });
  }

  Future<void> _onActivate() async {
    if (!mounted) return;
    if (_busy) return;
    switch (_focusIndex) {
      case 4:
        setState(() => _pendingFullscreen = !_pendingFullscreen);
        break;
      case 5:
        // Select background/menu music file
        try {
          final result = await FilePicker.platform.pickFiles(
              type: FileType.custom,
              allowedExtensions: ['mp3', 'wav', 'ogg', 'flac', 'm4a', 'aac']);
          if (result != null && result.files.isNotEmpty) {
            final path = result.files.single.path;
            if (path != null) {
              setState(() {
                _pendingBgMusicPath = path;
                _pendingBgMusicEnabled = true;
              });
            }
          }
        } catch (e) {
          debugPrint('Error picking bg music: $e');
        }
        break;
      case 6:
        setState(() => _pendingInvertYAxis = !_pendingInvertYAxis);
        break;
      case 7:
        await _savePendingAndClose();
        break;
      case 8:
        _resetPendingToDefaults();
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content: Text(
                'Valores restaurados en borrador. Pulsa Guardar para aplicar.')));
        break;
      case 9:
        _onBack();
        break;
    }
  }

  void _onBack() {
    if (mounted) Navigator.pop(context);
  }

  void _applyFromController() {
    final now = DateTime.now().millisecondsSinceEpoch;
    if (_busy) return;
    if (now - _lastActionAt < _actionDebounceMs) return;
    _lastActionAt = now;
    _savePendingAndClose();
  }

  void _resetFromController() {
    final now = DateTime.now().millisecondsSinceEpoch;
    if (_busy) return;
    if (now - _lastActionAt < _actionDebounceMs) return;
    _lastActionAt = now;
    _resetPendingToDefaults();
    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
        content: Text(
            'Valores restaurados en borrador. Pulsa Guardar para aplicar.')));
  }

  void _resetPendingToDefaults() {
    setState(() {
      _pendingMasterVolume = 1.0;
      _pendingMusicVolume = 0.7;
      _pendingSfxVolume = 1.0;
      _pendingFullscreen = false;
      _pendingWindowSize = const Size(1280, 800);
      _pendingBgMusicEnabled = true;
      _pendingBgMusicPath = null;
      _pendingInvertYAxis = false;

      // si tenemos resoluciones detectadas, mapear al más cercano
      if (_resolutions.isNotEmpty) {
        final idx = s.indexOfAvailable(_pendingWindowSize!);
        if (idx >= 0) {
          _pendingWindowResolutionIndex = idx;
        } else {
          final closest = s.mapToClosestAvailable(_pendingWindowSize!);
          _pendingWindowResolutionIndex =
              _resolutions.indexOf(closest).clamp(0, _resolutions.length - 1);
          _pendingWindowSize = _resolutions[_pendingWindowResolutionIndex];
        }
      } else {
        _pendingWindowResolutionIndex = 0;
      }
    });
  }

  Future<void> _savePendingAndClose() async {
    if (_busy) return;
    setState(() => _busy = true);
    try {
      // Asegurar coherencia: si hay resoluciones detectadas usamos la seleccionada por índice
      if (_resolutions.isNotEmpty) {
        _pendingWindowSize = _resolutions[
            _pendingWindowResolutionIndex.clamp(0, _resolutions.length - 1)];
      }

      // Aplicar borrador a SettingsService (runtime)
      s.masterVolume.value = _pendingMasterVolume;
      s.musicVolume.value = _pendingMusicVolume;
      s.sfxVolume.value = _pendingSfxVolume;
      s.bgMusicEnabled.value = _pendingBgMusicEnabled;
      s.audio.bgMusicPath.value = _pendingBgMusicPath;

      await s.applyWindowSettings(
          fullscreen: _pendingFullscreen,
          size: _pendingWindowSize,
          persist: true);

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Configuración guardada y aplicada.')));

      // Pop back to first route (same comportamiento anterior)
      try {
        Navigator.of(context).popUntil((route) => route.isFirst);
      } catch (e) {
        try {
          Navigator.maybePop(context);
        } catch (_) {}
      }
    } catch (e) {
      debugPrint('Error saving settings: $e');
      if (mounted)
        ScaffoldMessenger.of(context)
            .showSnackBar(SnackBar(content: Text('Error guardando: $e')));
    } finally {
      await Future.delayed(const Duration(milliseconds: 120));
      if (mounted) setState(() => _busy = false);
    }
  }

  void _ensureFocusVisible() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      final key = _focusKeys[_focusIndex];
      if (key != null && key.currentContext != null) {
        Scrollable.ensureVisible(key.currentContext!,
            duration: const Duration(milliseconds: 220),
            curve: Curves.easeInOut,
            alignment: 0.15);
      }
    });
  }

  String _resLabel(Size r) => '${r.width.toInt()} x ${r.height.toInt()}';

  // Opción row ahora detecta clicks para que mouse + teclado compartan foco
  Widget _optionRow({
    required int index,
    required String label,
    required Widget control,
    String? valueLabel,
  }) {
    final selected = _focusIndex == index;
    return GestureDetector(
      onTap: () {
        setState(() => _focusIndex = index);
        _ensureFocusVisible();
        FocusScope.of(context).requestFocus(_keyboardFocusNode);
      },
      child: ClipRRect(
        borderRadius: BorderRadius.circular(6.0),
        child: Container(
          key: _focusKeys[index],
          margin: const EdgeInsets.symmetric(vertical: 6.0),
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
          decoration: BoxDecoration(
            color: selected
                ? const Color(0xFF66E0FF).withOpacity(0.10)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(6.0),
            border: selected
                ? Border.all(color: const Color(0xFF66E0FF), width: 2.0)
                : null,
          ),
          child: Row(children: [
            Flexible(
                flex: 3,
                child: Text(label,
                    style: TextStyle(
                        color: selected ? Colors.white : Colors.white70,
                        fontWeight:
                            selected ? FontWeight.w700 : FontWeight.w600))),
            const SizedBox(width: 12),
            if (valueLabel != null)
              ConstrainedBox(
                  constraints: BoxConstraints(minWidth: 56, maxWidth: 120),
                  child: Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 10.0, vertical: 6.0),
                      decoration: BoxDecoration(
                          color: Colors.white12,
                          borderRadius: BorderRadius.circular(6.0)),
                      child: Text(valueLabel,
                          style: const TextStyle(color: Colors.white),
                          textAlign: TextAlign.center))),
            const SizedBox(width: 12),
            Flexible(
                flex: 2,
                child: ConstrainedBox(
                    constraints: BoxConstraints(maxWidth: 420),
                    child: control)),
          ]),
        ),
      ),
    );
  }

  Widget _actionButtonRow({
    required int index,
    required Widget child,
    required Color highlightColor,
  }) {
    final selected = _focusIndex == index;
    return GestureDetector(
      onTap: () {
        setState(() => _focusIndex = index);
        _onActivate();
      },
      child: ClipRRect(
        borderRadius: BorderRadius.circular(8.0),
        child: Container(
          key: _focusKeys[index],
          margin: const EdgeInsets.symmetric(vertical: 8.0),
          decoration: BoxDecoration(
            color: selected
                ? highlightColor.withOpacity(0.12)
                : Colors.transparent,
            border: selected
                ? Border.all(color: highlightColor, width: 2.0)
                : Border.all(color: Colors.transparent),
            borderRadius: BorderRadius.circular(8.0),
          ),
          child: child,
        ),
      ),
    );
  }

  Widget _psButtonGlyph(String glyph, Color color) {
    return Container(
      width: 28,
      height: 28,
      decoration:
          BoxDecoration(color: color.withOpacity(0.12), shape: BoxShape.circle),
      alignment: Alignment.center,
      child: Text(glyph,
          style: TextStyle(
              color: color, fontWeight: FontWeight.bold, fontSize: 14)),
    );
  }

  // ------------------ teclado -> acciones (unificadas con mando) ------------------
  void _handleRawKey(RawKeyEvent event) {
    // solo en down events para evitar duplicados
    if (event is! RawKeyDownEvent) return;
    final key = event.logicalKey;
    final now = DateTime.now().millisecondsSinceEpoch;
    if (now - _lastActionAt < _actionDebounceMs) return;
    _lastActionAt = now;

    if (key == LogicalKeyboardKey.arrowUp) {
      _onUp();
      return;
    }
    if (key == LogicalKeyboardKey.arrowDown) {
      _onDown();
      return;
    }
    if (key == LogicalKeyboardKey.arrowLeft) {
      _onLeft();
      return;
    }
    if (key == LogicalKeyboardKey.arrowRight) {
      _onRight();
      return;
    }
    if (key == LogicalKeyboardKey.enter ||
        key == LogicalKeyboardKey.numpadEnter ||
        key == LogicalKeyboardKey.space) {
      _onActivate();
      return;
    }
    if (key == LogicalKeyboardKey.escape ||
        key == LogicalKeyboardKey.backspace) {
      _onBack();
      return;
    }
    // teclas rápidas: A = aplicar, R = reset borrador
    if (key == LogicalKeyboardKey.keyA) {
      _applyFromController();
      return;
    }
    if (key == LogicalKeyboardKey.keyR) {
      _resetFromController();
      return;
    }
  }

  @override
  Widget build(BuildContext context) {
    return RawKeyboardListener(
      focusNode: _keyboardFocusNode,
      onKey: _handleRawKey,
      child: Scaffold(
        backgroundColor: Colors.transparent,
        body: SafeArea(
          child: LayoutBuilder(builder: (context, constraints) {
            final maxWidth = constraints.maxWidth;
            final maxHeight = constraints.maxHeight;
            final panelMaxWidth = min(maxWidth * 0.98, maxWidth);
            final panelMaxHeight = min(maxHeight * 0.96, maxHeight);

            return Stack(fit: StackFit.expand, children: [
              if (_bgLoaded && _bgImage != null)
                Positioned.fill(
                    child: Image(image: _bgImage!, fit: BoxFit.cover)),
              Positioned.fill(
                  child: BackdropFilter(
                      filter: ui.ImageFilter.blur(sigmaX: 6.0, sigmaY: 6.0),
                      child: Container(color: Colors.black.withOpacity(0.22)))),
              Center(
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(14.0),
                  child: Container(
                    width: panelMaxWidth,
                    height: panelMaxHeight,
                    color: const Color(0x0D000000),
                    child: Row(children: [
                      // LEFT: options list
                      Expanded(
                        flex: 6,
                        child: Padding(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 22.0, vertical: 18.0),
                            child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(children: [
                                    Container(
                                        width: 44,
                                        height: 44,
                                        decoration: BoxDecoration(
                                            color: const Color(0xFF1E90FF),
                                            shape: BoxShape.circle),
                                        child: const Icon(Icons.settings,
                                            color: Colors.white)),
                                    const SizedBox(width: 14),
                                    const Text('AJUSTES',
                                        style: TextStyle(
                                            color: Colors.white,
                                            fontSize: 22,
                                            fontWeight: FontWeight.bold))
                                  ]),
                                  const SizedBox(height: 16),
                                  Expanded(
                                      child: ListView(
                                          controller: _scrollController,
                                          padding: const EdgeInsets.only(
                                              right: 16.0, bottom: 12.0),
                                          children: [
                                        // Volumen maestro
                                        _optionRow(
                                            index: 0,
                                            label: 'Volumen maestro',
                                            valueLabel:
                                                '${(_pendingMasterVolume * 100).toInt()}%',
                                            control: Slider(
                                              value: _pendingMasterVolume,
                                              min: 0,
                                              max: 1,
                                              divisions: 100,
                                              onChangeStart: (_) {
                                                FocusScope.of(context)
                                                    .requestFocus(
                                                        _keyboardFocusNode);
                                                setState(() => _focusIndex = 0);
                                              },
                                              onChanged: (v) => setState(() =>
                                                  _pendingMasterVolume = v),
                                            )),
                                        // Volumen música (no aplicar en vivo)
                                        _optionRow(
                                          index: 1,
                                          label: 'Volumen música',
                                          valueLabel:
                                              '${(_pendingMusicVolume * 100).toInt()}%',
                                          control: Slider(
                                            value: _pendingMusicVolume,
                                            min: 0,
                                            max: 1,
                                            divisions: 100,
                                            onChangeStart: (_) {
                                              FocusScope.of(context)
                                                  .requestFocus(
                                                      _keyboardFocusNode);
                                              setState(() => _focusIndex = 1);
                                            },
                                            onChanged: (v) => setState(
                                                () => _pendingMusicVolume = v),
                                          ),
                                        ),
                                        // Volumen SFX
                                        _optionRow(
                                            index: 2,
                                            label: 'Volumen SFX',
                                            valueLabel:
                                                '${(_pendingSfxVolume * 100).toInt()}%',
                                            control: Slider(
                                                value: _pendingSfxVolume,
                                                min: 0,
                                                max: 1,
                                                divisions: 100,
                                                onChangeStart: (_) {
                                                  FocusScope.of(context)
                                                      .requestFocus(
                                                          _keyboardFocusNode);
                                                  setState(
                                                      () => _focusIndex = 2);
                                                },
                                                onChanged: (v) => setState(() =>
                                                    _pendingSfxVolume = v))),

                                        const SizedBox(height: 12),
                                        Padding(
                                            padding: const EdgeInsets.symmetric(
                                                vertical: 8.0),
                                            child: Text('PANTALLA',
                                                style: TextStyle(
                                                    color: Colors.white70,
                                                    fontWeight:
                                                        FontWeight.bold))),

                                        // Resolución: usamos índice como value (robusto)
                                        _optionRow(
                                            index: 3,
                                            label: 'Resolución',
                                            valueLabel: _pendingWindowSize !=
                                                    null
                                                ? _resLabel(_pendingWindowSize!)
                                                : '',
                                            control: GestureDetector(
                                              onTap: () {
                                                FocusScope.of(context)
                                                    .requestFocus(
                                                        _keyboardFocusNode);
                                                setState(() => _focusIndex = 3);
                                              },
                                              child: (_resolutions.isNotEmpty)
                                                  ? DropdownButton<int>(
                                                      value: _pendingWindowResolutionIndex
                                                          .clamp(
                                                              0,
                                                              _resolutions
                                                                      .length -
                                                                  1),
                                                      isDense: true,
                                                      dropdownColor:
                                                          const Color(
                                                              0xFF021829),
                                                      items: List.generate(
                                                          _resolutions.length,
                                                          (i) {
                                                        final r =
                                                            _resolutions[i];
                                                        return DropdownMenuItem<
                                                            int>(
                                                          value: i,
                                                          child: Text(
                                                              _resLabel(r),
                                                              style: const TextStyle(
                                                                  color: Colors
                                                                      .white)),
                                                        );
                                                      }),
                                                      onChanged: (i) {
                                                        if (i == null) return;
                                                        setState(() {
                                                          _pendingWindowResolutionIndex =
                                                              i;
                                                          _pendingWindowSize =
                                                              _resolutions[i];
                                                        });
                                                      },
                                                    )
                                                  : TextButton(
                                                      onPressed: null,
                                                      child: const Text(
                                                          'Cargando resoluciones...',
                                                          style: TextStyle(
                                                              color: Colors
                                                                  .white54)),
                                                    ),
                                            )),

                                        _optionRow(
                                            index: 4,
                                            label: 'Pantalla completa',
                                            control: GestureDetector(
                                              onTap: () {
                                                FocusScope.of(context)
                                                    .requestFocus(
                                                        _keyboardFocusNode);
                                                setState(() => _focusIndex = 4);
                                              },
                                              child: Switch(
                                                  value: _pendingFullscreen,
                                                  onChanged: (v) => setState(
                                                      () => _pendingFullscreen =
                                                          v)),
                                            ),
                                            valueLabel: _pendingFullscreen
                                                ? 'Sí'
                                                : 'No'),

                                        const SizedBox(height: 12),
                                        Padding(
                                            padding: const EdgeInsets.symmetric(
                                                vertical: 8.0),
                                            child: Text('CONTROLES',
                                                style: TextStyle(
                                                    color: Colors.white70,
                                                    fontWeight:
                                                        FontWeight.bold))),

                                        _optionRow(
                                            index: 5,
                                            label: 'Música del menú',
                                            valueLabel: _pendingBgMusicPath != null
                                                ? _pendingBgMusicPath!.replaceAll('\\', '/').split('/').last
                                                : (_pendingBgMusicEnabled ? 'Predeterminada' : 'Desactivada'),
                                            control: Row(children: [
                                              Switch(
                                                value: _pendingBgMusicEnabled,
                                                onChanged: (v) => setState(() {
                                                  _pendingBgMusicEnabled = v;
                                                }),
                                              ),
                                              const SizedBox(width: 8),
                                              TextButton(
                                                onPressed: () async {
                                                  try {
                                                    final result = await FilePicker.platform.pickFiles(
                                                        type: FileType.custom,
                                                        allowedExtensions: ['mp3', 'wav', 'ogg', 'flac', 'm4a', 'aac']);
                                                    if (result != null && result.files.isNotEmpty) {
                                                      final path = result.files.single.path;
                                                      if (path != null) {
                                                        setState(() {
                                                          _pendingBgMusicPath = path;
                                                          _pendingBgMusicEnabled = true;
                                                        });
                                                      }
                                                    }
                                                  } catch (e) {
                                                    debugPrint('Error picking bg music: $e');
                                                  }
                                                },
                                                child: const Text('Seleccionar', style: TextStyle(color: Colors.white)),
                                              )
                                            ])),

                                        const SizedBox(height: 14),
                                        _actionButtonRow(
                                          index: 7,
                                          highlightColor:
                                              const Color(0xFF2ECC71),
                                          child: SizedBox(
                                            width: double.infinity,
                                            child: TextButton.icon(
                                              style: TextButton.styleFrom(
                                                  padding: const EdgeInsets
                                                      .symmetric(
                                                      vertical: 14.0),
                                                  backgroundColor:
                                                      _focusIndex == 7
                                                          ? const Color(
                                                                  0xFF2ECC71)
                                                              .withOpacity(0.12)
                                                          : null),
                                              onPressed: _busy
                                                  ? null
                                                  : () async {
                                                      setState(() =>
                                                          _focusIndex = 7);
                                                      await _savePendingAndClose();
                                                    },
                                              icon: Row(children: [
                                                _psButtonGlyph('▲',
                                                    const Color(0xFF2ECC71)),
                                                const SizedBox(width: 12),
                                                const Icon(Icons.check,
                                                    color: Colors.white)
                                              ]),
                                              label: const Text(
                                                  'Guardar (Aplicar cambios)',
                                                  style: TextStyle(
                                                      color: Colors.white)),
                                            ),
                                          ),
                                        ),
                                        _actionButtonRow(
                                          index: 8,
                                          highlightColor:
                                              const Color(0xFF8E44AD),
                                          child: SizedBox(
                                            width: double.infinity,
                                            child: TextButton.icon(
                                              style: TextButton.styleFrom(
                                                  padding: const EdgeInsets
                                                      .symmetric(
                                                      vertical: 14.0),
                                                  backgroundColor:
                                                      _focusIndex == 8
                                                          ? const Color(
                                                                  0xFF8E44AD)
                                                              .withOpacity(0.10)
                                                          : null),
                                              onPressed: _busy
                                                  ? null
                                                  : () {
                                                      setState(() =>
                                                          _focusIndex = 8);
                                                      _resetPendingToDefaults();
                                                      ScaffoldMessenger.of(
                                                              context)
                                                          .showSnackBar(
                                                              const SnackBar(
                                                                  content: Text(
                                                                      'Valores restaurados en borrador. Pulsa Guardar para aplicar.')));
                                                    },
                                              icon: Row(children: [
                                                _psButtonGlyph('◻',
                                                    const Color(0xFF8E44AD)),
                                                const SizedBox(width: 12),
                                                const Icon(Icons.restore,
                                                    color: Colors.white)
                                              ]),
                                              label: const Text(
                                                  'Restablecer (Borrador)',
                                                  style: TextStyle(
                                                      color: Colors.white)),
                                            ),
                                          ),
                                        ),
                                        _actionButtonRow(
                                          index: 9,
                                          highlightColor: Colors.red,
                                          child: SizedBox(
                                            width: double.infinity,
                                            child: TextButton.icon(
                                              style: TextButton.styleFrom(
                                                  padding: const EdgeInsets
                                                      .symmetric(
                                                      vertical: 14.0),
                                                  backgroundColor:
                                                      _focusIndex == 9
                                                          ? Colors.red
                                                              .withOpacity(0.10)
                                                          : null),
                                              onPressed: _busy
                                                  ? null
                                                  : () {
                                                      setState(() =>
                                                          _focusIndex = 9);
                                                      _onBack();
                                                    },
                                              icon: Row(children: [
                                                _psButtonGlyph('✕', Colors.red),
                                                const SizedBox(width: 12),
                                                const Icon(Icons.close,
                                                    color: Colors.white)
                                              ]),
                                              label: const Text(
                                                  'Cancelar (Descartar)',
                                                  style: TextStyle(
                                                      color: Colors.white)),
                                            ),
                                          ),
                                        ),
                                        const SizedBox(height: 12),
                                      ])),
                                ])),
                      ),

                      // RIGHT: help / preview area
                      Expanded(
                        flex: 4,
                        child: Padding(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 16.0, vertical: 18.0),
                          child: Container(
                            padding: const EdgeInsets.all(16.0),
                            decoration: BoxDecoration(
                                color: Colors.black.withOpacity(0.12),
                                borderRadius: BorderRadius.circular(10.0)),
                            child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  const SizedBox(height: 12),
                                  Text(_helpTextForIndex(_focusIndex),
                                      style: const TextStyle(
                                          color: Colors.white70)),
                                  const SizedBox(height: 12),
                                  const Text('Descripción',
                                      style: TextStyle(
                                          color: Colors.white54,
                                          fontWeight: FontWeight.bold)),
                                  const SizedBox(height: 8),
                                  const Text(
                                      'Los cambios quedan pendientes hasta que pulses Guardar. Pulsa ▲ para aplicar o ◻ para restablecer el borrador. Si sales sin guardar, los cambios se descartarán.',
                                      style: TextStyle(color: Colors.white54)),
                                  const Spacer(),
                                  Row(
                                      mainAxisAlignment: MainAxisAlignment.end,
                                      children: [
                                        Row(children: [
                                          _psButtonGlyph(
                                              '▲', const Color(0xFF2ECC71)),
                                          const SizedBox(width: 8),
                                          const Text('Aplicar',
                                              style: TextStyle(
                                                  color: Colors.white70))
                                        ]),
                                        const SizedBox(width: 12),
                                        Row(children: [
                                          _psButtonGlyph(
                                              '◻', const Color(0xFF8E44AD)),
                                          const SizedBox(width: 8),
                                          const Text('Restablecer',
                                              style: TextStyle(
                                                  color: Colors.white70))
                                        ]),
                                        const SizedBox(width: 12),
                                        Row(children: [
                                          _psButtonGlyph('✕', Colors.red),
                                          const SizedBox(width: 8),
                                          const Text('Descartar',
                                              style: TextStyle(
                                                  color: Colors.white70))
                                        ])
                                      ]),
                                ]),
                          ),
                        ),
                      ),
                    ]),
                  ),
                ),
              ),
            ]);
          }),
        ),
      ),
    );
  }

  String _helpTextForIndex(int index) {
    switch (index) {
      case 0:
        return 'Ajusta el volumen general de todos los sonidos del juego.';
      case 1:
        return 'Controla el volumen de la música de fondo. (Borrador)';
      case 2:
        return 'Ajusta el volumen de los efectos de sonido (SFX).';
      case 3:
        return 'Selecciona la resolución de la ventana (detectadas por el sistema).';
      case 4:
        return 'Alterna entre modo ventana y pantalla completa.';
      case 5:
        return 'Selecciona o desactiva la música que sonará en el menú.';
      case 6:
        return 'Invierte el eje vertical (Y) para el control de la cámara.';
      case 7:
        return 'Pulsa ▲ para guardar y aplicar los cambios.';
      case 8:
        return 'Pulsa ◻ para restablecer los valores predeterminados (borrador).';
      case 9:
        return 'Descartar: cerrar el panel sin aplicar cambios.';
      default:
        return 'Navega con el mando o el teclado para configurar las opciones.';
    }
  }
}
