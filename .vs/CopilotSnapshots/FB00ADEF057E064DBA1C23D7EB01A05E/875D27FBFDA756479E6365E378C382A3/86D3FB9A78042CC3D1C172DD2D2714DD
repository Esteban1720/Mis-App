// lib/services/input_service.dart
// InputService with hold/repeat behavior and enhanced debug logging

import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';
import 'package:win32_gamepad/win32_gamepad.dart' show Gamepad, GamepadState;

typedef VoidCb = void Function();

class InputListener {
  VoidCb? onLeft, onRight, onUp, onDown, onActivate, onBack, onToggleFullscreen, onSelect, onShare, onSettings;
  InputListener({this.onLeft, this.onRight, this.onUp, this.onDown, this.onActivate, this.onBack, this.onToggleFullscreen, this.onSelect, this.onShare, this.onSettings});
}

class InputService {
  InputService._internal();
  static final InputService _instance = InputService._internal();
  static InputService get instance => _instance;
  bool _initialized = false;
  VoidCb? onLeft, onRight, onUp, onDown, onActivate, onBack, onToggleFullscreen, onSelect, onShare, onSettings;
  final List<InputListener> _listeners = [];
  final Map<String, int> _lastFired = {};
  final int _debounceMs = 120;
  Timer? _pollTimer;
  final List<Gamepad> _pads = [];
  final List<GamepadState?> _prevStates = [];
  final Map<String, Timer?> _repeatTimers = {};
  StreamSubscription<dynamic>? _subscription;
  int _initialRepeatDelay = 300;
  int _repeatInterval = 80;
  bool _enableDebug = true;
  void _d(String msg) { if (_enableDebug) debugPrint('InputService: $msg'); }

  Future<void> initialize({bool enableDebug = true, int? initialDelayMs, int? repeatIntervalMs}) async {
    if (_initialized) return;
    _enableDebug = enableDebug;
    if (initialDelayMs != null) _initialRepeatDelay = initialDelayMs;
    if (repeatIntervalMs != null) _repeatInterval = repeatIntervalMs;
    if (Platform.isWindows) {
      _startWindowsPolling();
    } else {
      _initGeneric();
    }
    _initialized = true;
  }

  Future<void> suspend() async {
    if (!_initialized) return;
    if (Platform.isWindows) {
      _stopWindowsPolling();
    } else {
      try { _subscription?.pause(); } catch (_) {}
    }
  }

  Future<void> resume() async {
    if (!_initialized) return;
    if (Platform.isWindows) {
      _startWindowsPolling();
    } else {
      try { _subscription?.resume(); } catch (_) {}
    }
  }

  void dispose() {
    if (!_initialized) return;
    if (Platform.isWindows) {
      _stopWindowsPolling();
    } else {
      _subscription?.cancel();
      _subscription = null;
    }
    _initialized = false;
  }

  void _initGeneric() {}

  VoidCb pushListener(InputListener listener) {
    _listeners.add(listener);
    return () { _listeners.remove(listener); };
  }

  InputListener? get _topListener => _listeners.isNotEmpty ? _listeners.last : null;

  void _dispatch(VoidCb? Function(InputListener l) selector, VoidCb? fallback) {
    final top = _topListener;
    try {
      if (top != null) {
        final cb = selector(top);
        if (cb != null) { cb(); return; }
      }
      if (fallback != null) fallback();
    } catch (_) {}
  }

  String _repeatKey(String action, int padIndex) => '$action:$padIndex';

  void _startRepeat(String key, VoidCb trigger) {
    try { _repeatTimers[key]?.cancel(); } catch (_) {}
    Timer? initialTimer;
    initialTimer = Timer(Duration(milliseconds: _initialRepeatDelay), () {
      try { trigger(); } catch (_) {}
      try {
        _repeatTimers[key] = Timer.periodic(Duration(milliseconds: _repeatInterval), (_) { try { trigger(); } catch (_) {} });
      } catch (_) {}
    });
    _repeatTimers[key] = initialTimer;
  }

  void _stopRepeat(String key) {
    try { _repeatTimers[key]?.cancel(); } catch (_) {}
    _repeatTimers.remove(key);
  }

  int _now() => DateTime.now().millisecondsSinceEpoch;
  bool _shouldFire(String key) { final now = _now(); final last = _lastFired[key] ?? 0; if (now - last < _debounceMs) return false; _lastFired[key] = now; return true; }

  void _startWindowsPolling() {
    if (_pollTimer != null) return;
    _pads.clear(); _prevStates.clear();
    for (var i = 0; i < 4; i++) {
      try { final pad = Gamepad(i); _pads.add(pad); _prevStates.add(pad.state); } catch (_) {}
    }
    if (_pads.isEmpty) return;
    _pollTimer = Timer.periodic(const Duration(milliseconds: 60), (_) {
      try {
        for (var i = 0; i < _pads.length; i++) {
          final pad = _pads[i]; pad.updateState(); final state = pad.state; final prev = _prevStates[i]!;
          if (state.dpadUp && !prev.dpadUp) { final key = _repeatKey('up', i); if (_shouldFire('up:$i')) _dispatch((l) => l.onUp, onUp); _startRepeat(key, () => _dispatch((l) => l.onUp, onUp)); } else if (!state.dpadUp && prev.dpadUp) { _stopRepeat(_repeatKey('up', i)); }
          if (state.dpadDown && !prev.dpadDown) { final key = _repeatKey('down', i); if (_shouldFire('down:$i')) _dispatch((l) => l.onDown, onDown); _startRepeat(key, () => _dispatch((l) => l.onDown, onDown)); } else if (!state.dpadDown && prev.dpadDown) { _stopRepeat(_repeatKey('down', i)); }
          if (state.dpadLeft && !prev.dpadLeft) { final key = _repeatKey('left', i); if (_shouldFire('left:$i')) _dispatch((l) => l.onLeft, onLeft); _startRepeat(key, () => _dispatch((l) => l.onLeft, onLeft)); } else if (!state.dpadLeft && prev.dpadLeft) { _stopRepeat(_repeatKey('left', i)); }
          if (state.dpadRight && !prev.dpadRight) { final key = _repeatKey('right', i); if (_shouldFire('right:$i')) _dispatch((l) => l.onRight, onRight); _startRepeat(key, () => _dispatch((l) => l.onRight, onRight)); } else if (!state.dpadRight && prev.dpadRight) { _stopRepeat(_repeatKey('right', i)); }
          if (state.buttonA && !prev.buttonA) { if (_shouldFire('activate:$i')) _dispatch((l) => l.onActivate, onActivate); }
          if (state.buttonB && !prev.buttonB) { if (_shouldFire('back:$i')) _dispatch((l) => l.onBack, onBack); }
          if (state.buttonStart && !prev.buttonStart) { if (_shouldFire('toggle_fs:$i')) _dispatch((l) => l.onToggleFullscreen, onToggleFullscreen); }
          if (state.buttonBack && !prev.buttonBack) { if (_shouldFire('select:$i')) _dispatch((l) => l.onSelect, onSelect); }
          if (state.buttonX && !prev.buttonX) { if (_shouldFire('share:$i')) _dispatch((l) => l.onShare, onShare); }
          if (state.buttonY && !prev.buttonY) { if (_shouldFire('settings:$i')) _dispatch((l) => l.onSettings, onSettings); }
          const dead = 12000;
          if (state.leftThumbstickX <= -dead && prev.leftThumbstickX > -dead) { final key = _repeatKey('left', i); if (_shouldFire('left:$i')) _dispatch((l) => l.onLeft, onLeft); _startRepeat(key, () => _dispatch((l) => l.onLeft, onLeft)); } else if (state.leftThumbstickX > -dead && prev.leftThumbstickX <= -dead) { _stopRepeat(_repeatKey('left', i)); } else if (state.leftThumbstickX >= dead && prev.leftThumbstickX < dead) { final key = _repeatKey('right', i); if (_shouldFire('right:$i')) _dispatch((l) => l.onRight, onRight); _startRepeat(key, () => _dispatch((l) => l.onRight, onRight)); } else if (state.leftThumbstickX < dead && prev.leftThumbstickX >= dead) { _stopRepeat(_repeatKey('right', i)); }
          if (state.leftThumbstickY >= dead && prev.leftThumbstickY < dead) { final key = _repeatKey('up', i); if (_shouldFire('up:$i')) _dispatch((l) => l.onUp, onUp); _startRepeat(key, () => _dispatch((l) => l.onUp, onUp)); } else if (state.leftThumbstickY < dead && prev.leftThumbstickY >= dead) { _stopRepeat(_repeatKey('up', i)); } else if (state.leftThumbstickY <= -dead && prev.leftThumbstickY > -dead) { final key = _repeatKey('down', i); if (_shouldFire('down:$i')) _dispatch((l) => l.onDown, onDown); _startRepeat(key, () => _dispatch((l) => l.onDown, onDown)); } else if (state.leftThumbstickY > -dead && prev.leftThumbstickY <= -dead) { _stopRepeat(_repeatKey('down', i)); }
          _prevStates[i] = state;
        }
      } catch (_) {}
    });
  }

  void _stopWindowsPolling() {
    _pollTimer?.cancel(); _pollTimer = null;
    for (final key in _repeatTimers.keys.toList()) { try { _repeatTimers[key]?.cancel(); } catch (_) {} }
    _repeatTimers.clear(); _pads.clear(); _prevStates.clear();
  }

  Future<void> toggleFullscreen() async {
    try {
      final isFull = await windowManager.isFullScreen();
      await windowManager.setFullScreen(!isFull);
      await windowManager.focus();
    } catch (_) {}
  }
}
